instructions:
  ADD:
    category: arithmetic
    documentation_short: Add two numerical values
    documentation: |
        Adds numerical values.
        This instruction is polymorphic and accepts any combination of natural numbers and integers as operands.
        The return value is a natural number if both operands are natural. Otherwise, it is an integer.

        Furthermore, integers can be added to timestamps in which case
        the return value is a timestamp offset with the integer number
        of seconds.

        Finally, a ``mutez`` can be added to a ``mutez``, in which case the return value is a ``mutez``.

    examples:
      - name: Various additions
        description: This example demonstrates the addition of different types of numbers and domain specific types.
        path: opcodes/add.tz
        input: 'Unit'
        initial_storage: 'Unit'
        final_storage: 'Unit'
        hide_final_storage: True
  ADDRESS:
    category: blockchain
    documentation_short: Push the address of a contract
    documentation: |
      This instruction consumes a contract value and produces the address of that contract.

    examples:
      - name: Address examples
        description: This demonstrates takes a contract  by parameter, and then stores its address.
        path: opcodes/address.tz
        input: '"tz1b7tUupMgCNw2cCLpKTkSD1NZzB5TkP2sv"'
        initial_storage: 'None'
        final_storage: '(Some "tz1b7tUupMgCNw2cCLpKTkSD1NZzB5TkP2sv")'

  LOOP_LEFT:
    category: control_structure
    documentation_short: Loop with accumulator
    documentation: |
        The ``LOOP_LEFT body`` instruction executes ``body`` as long
        as the top element of the stack is ``(Left a)``. The ``body``
        of the loop must consume a value of type ``a`` and produce a
        value of type ``(or a b)``.

        If the top element is ``(Right b)``, at the beginning of the loop or at
        the end of an iteration, then the loop is terminated and this value is
        left on the top of the stack.

    examples:
      - name: Sum list
        description: This contract reverses the list of strings passed by parameter and stores it.
        path: opcodes/loop_left.tz
        input: '{ "a" ; "b" ; "c" }'
        initial_storage: '{}'
        final_storage: '{ "c" ; "b" ; "a" }'
  CDR:
    category: data_structure
    documentation_short: Access the right part of a pair
    examples:
      - name: Store right parameter
        description: |
          This contract takes a pair as parameter. It selects the right
          part of the parameter and stores it.

        path: opcodes/cdr.tz
        input: '(Pair 15 9)'
        initial_storage: '0'
        final_storage: '9'
  CAR:
    category: data_structure
    documentation_short: Access the left part of a pair
    examples:
      - name: Store left parameter
        description: |
          This contract takes a pair as parameter. It selects the left
          part of the parameter and stores it.

        path: opcodes/car.tz
        input: '(Pair 15 9)'
        initial_storage: '0'
        final_storage: '15'
  CHAIN_ID:
    category: blockchain
    documentation_short: Push the chain identifier
    examples:
      - name: Push the chain identifier.
        description: |
          This contract pushes and then stores the chain identifier.

        path: opcodes/chain_id_store.tz
        input: 'Unit'
        initial_storage: 'None'
        final_storage: '(Some 0x7a06a770)'
        hide_final_storage: True
  DIP:
    category: stack
    documentation_short: Run code protecting the top of the stack
    documentation: |
      ``DIP n code`` runs ``code`` protecting the ``n`` topmost
      elements of the stack. In particular, ``DIP 0 code`` is
      equivalent to ``code`` and ``DIP 1 code`` is equivalent to ``DIP
      code``.


    examples:
      - description: |
          This examples takes a pair of integers ``(a, b)`` as parameter,
          and stores ``(a, a + b)``

        path: opcodes/dip.tz
        input: '(Pair 15 9)'
        initial_storage: '(Pair 0 0)'
        final_storage: '(Pair 15 24)'
  DUP:
    category: stack
    documentation_short: Duplicate the top of the stack

  DROP:
    category: stack
    documentation_short: Drop the top ``n`` elements of the stack
    documentation: |
      ``DROP n`` drops the `n` topmost elements of the stack. In
      particular, ``DROP 0`` is a noop and ``DROP 1`` is equivalent to
      ``DROP``.

  FAILWITH:
    category: control_structure
    documentation_short: Explicitly abort the current program
    documentation: |
      This instruction aborts the current program exposing the top element of the stack in its error message. It makes the output useless since all subsequent instructions will simply ignore their usual semantics to propagate the failure up to the main result. Its type is thus completely generic.

  IF:
    category: control_structure
    documentation_short: Conditional branching
    documentation: |
      The ``IF bt bf`` instruction consumes a stack whose top element
      ``b`` is of type ``bool`` and an arbitrary remaining stack
      ``S``.

      This instruction executes the ``bt`` branch if ``b`` is
      ``True``, and the ``bf`` branch otherwise.

      Note that both branches must return a stack of the same type.

  IF_CONS:
    category: control_structure
    documentation_short: Inspect a list
    documentation: |
      The ``IF_CONS bt bf`` instruction consumes a stack whose top
      element ``l`` has a list type ``list ty1`` and an arbitrary
      remaining stack ``S``.

      If the list ``l`` has at least one element ``hd`` followed by (a
      possibly empty) list ``tl``, then the ``bt`` branch is executed
      on the stack ``hd : tl : S``.  Otherwise, the ``bf`` branch is
      executed on the stack ``S``.

      Note that both branches must return a stack of the same type.

  IF_NONE:
    category: control_structure
    documentation_short: Inspect an optional value
    documentation: |
      The ``IF_NONE bt bf`` instruction consumes a stack whose top
      element ``v`` has an option type ``option ty1`` and an arbitrary
      remaining stack ``S``.

      If the optional value ``v`` is ``None``, then the ``bt``
      branch is executed on the stack ``S``.  If ``v`` is
      ``Some x``, then the ``bf`` branch is executed on the stack
      ``x : S``.

      Note that both branches must return a stack of the same type.

  IF_LEFT:
    category: control_structure
    documentation_short: Inspect a value of a union
    documentation: |
      The ``IF_LEFT bt bf`` instruction consumes a stack whose top
      element ``v`` has an union type ``or ty1 ty2`` and an arbitrary
      remaining stack ``S``.

      If the union ``v`` stack is ``Left x``, then the ``bt`` branch
      is executed on the stack ``x : S``.  If it is ``Right y``,
      then the ``bf`` branch is executed on the stack ``y : S``.

      Note that both branches must return a stack of the same type.

  LEFT:
    category: data_structure
    documentation_short: Wrap a value in a union (left case)
  NOOP:
    category: control_structure
    documentation_short: Empty instruction sequence
  PAIR:
    category: data_structure
    documentation_short: "Build a pair from the stack's top two elements"
  PUSH:
    category: stack
    documentation_short: Push a constant value of a given type onto the stack
  RIGHT:
    category: data_structure
    documentation_short: Wrap a value in a union (right case)
  SEQ:
    category: control_structure
    documentation_short: Instruction sequence
  SWAP:
    category: stack
    documentation_short: Swap the top two elements of the stack
    documentation: "The ``SWAP`` instruction swaps  the top two elements of the stack."
  PACK:
    category: data_structure
    documentation_short: Serialize data
    documentation: |
      Serializes any value of packable type to its optimized binary representation, of type ``bytes``.

    examples:
      - name: "``PACK`` -- ``UNPACK``"
        description: |
          This example packs the left part of the parameter, and
          asserts that it is equal to the right part of the parameter.
          It then verifies that the right part unpacks to a valid
          Michelson value.

        path: opcodes/packunpack.tz
        input: '(Pair (Pair (Pair "toto" {3;7;9;1}) {1;2;3}) 0x05070707070100000004746f746f020000000800030007000900010200000006000100020003)'
        initial_storage: 'Unit'
        final_storage: 'Unit'
  UNPACK:
    category: data_structure
    documentation_short: Deserialize data, if valid
    documentation: |
      Deserialize a value of type ``bytes`` into the corresponding
      Michelson value of type ``option ty1``.
      If the top of the stack is not the serialization of a Michelson
      value of type ``ty1``, then ``None`` is pushed.
      Otherwise, ``Some v`` is pushed, where ``v`` is the deserialized value.

    examples:
      - name: "``UNPACK`` reverses ``PACK``"
        description: |
          This example takes a tuple with a member of each comparable
          type, packs and unpacks each member and asserts that the
          resulting value is unchanged.

        path: opcodes/packunpack_rev.tz
        input: '(Pair -1  (Pair 1 (Pair "foobar" (Pair 0x00AABBCC (Pair 1000 (Pair False (Pair "tz1cxcwwnzENRdhe2Kb8ZdTrdNy4bFNyScx5" (Pair "2019-09-09T08:35:33Z" "tz1cxcwwnzENRdhe2Kb8ZdTrdNy4bFNyScx5"))))))))'
        initial_storage: 'Unit'
        final_storage: 'Unit'
  BLAKE2B:
    category: crypto
    documentation_short: Compute a Blake2B cryptographic hash
    documentation: |
      Compute the cryptographic hash of the top of the stack using the BLAKE2B cryptographic hash function.

    examples:
    - name: Hash and store
      description: This example computes the BLAKE2B hash of the string passed as parameter and puts it in storage.
      path: opcodes/hash_string.tz
      input: '"foobar"'
      initial_storage: 0x
      final_storage: '0xc5b7e76c15ce98128a840b54c38f462125766d2ed3a6bff0e76f7f3eb415df04'
  SHA256:
    category: crypto
    documentation_short: Compute a SHA-256 cryptographic hash
    documentation: |
      Compute the cryptographic hash of the top of the stack using the SHA-256 cryptographic hash function.
  SHA512:
    category: crypto
    documentation_short: Compute a SHA-512 cryptographic hash
    documentation: |
      Compute the cryptographic hash of the top of the stack using the SHA-512 cryptographic hash function.
  ABS:
    category: arithmetic
    documentation_short: Obtain the absolute value of an integer
    documentation: |
      ``ABS`` consumes an integer and pushes its absolute value, with type ``nat``, on the stack.

    examples:
      - name: '``ABS`` is the reverse of ``NEG`` on natural numbers.'
        description: |
          This examples negates a natural number, takes the absolute
          value and asserts that the final value equals the initial
          parameter.

          Note that this is true for any natural number, since
          Michelson numbers are arbitrary-precision.

        path: opcodes/abs.tz
        input: '12039123919239192312931'
        initial_storage: 'Unit'
        final_storage: 'Unit'
        hide_final_storage: True
  AMOUNT:
    category: blockchain
    documentation_short: Push the amount of the current transaction
    documentation: |
      Push the amount of the current transaction, in ``mutez``.

    examples:
      - name: Store ``AMOUNT``
        description: This contract stores the amount of its last received transaction.
        path: opcodes/transfer_amount.tz
        input: 'Unit'
        initial_storage: '0'
        final_storage: '50000'
        hide_final_storage: True
  AND:
    category: logic
    documentation_short: Boolean and bitwise AND
    documentation: |
      The instruction ``AND`` is defined on boolean and natural number operands.
      In the former case, the result is the logical AND of the operands.
      In the latter case, the result is the bitwise AND of the operands.

      ``AND`` is also defined for integer operands. Negative
      numbers are considered in `two's complement representation <https://en.wikipedia.org/wiki/Two's_complement>`_,
      starting with a virtual infinite number of 1s.

    examples:
    - name: Boolean AND
      description: This contracts takes a pair of booleans, and computes and stores their conjunction.
      path: opcodes/and_logical_1.tz
      initial_storage: 'False'
      input: '(Pair True False)'
      final_storage: 'False'

    - name: Bitwise AND
      description: This contract demonstrates bitwise AND on numerical values.
      path: opcodes/and_binary.tz
      initial_storage: 'Unit'
      input: 'Unit'
      final_storage: 'Unit'
      hide_final_storage: True
  BALANCE:
    category: blockchain
    documentation_short: Push the current amount of mutez of the executing contract
    documentation: |
      Push the current amount of mutez held by the executing contract,
      including any mutez added by the calling transaction.

    examples:
      - name: Store ``BALANCE``
        description: This contract stores its balance after its latest received transaction.
        path: opcodes/balance.tz
        input: 'Unit'
        initial_storage: '0'
        final_storage: '4000000000000'
        hide_final_storage: True
  CHECK_SIGNATURE:
    category: crypto
    documentation_short: 'Verify ``signature`` of ``bytes`` by ``key``'
    documentation: |
      Verifies that a byte sequence has been signed with a given key.
      This instruction consumes three operands: a ``key``, a ``signature`` and a
      byte sequence. It pushes ``True`` if and only if the signature is a
      valid signature of the byte sequence by the given key.

    examples:
    - name: Check signature
      description: |
          This contract stores a ``signature`` and a ``string``.  It
          takes a ``key`` as parameter and runs successfully if the
          stored ``signature`` is a valid signature of the BLAKE2B
          hash of the stored string by that ``key``.

      path: opcodes/check_signature.tz
      input: '"edpkuBknW28nW72KG6RoHtYW7p12T6GKc7nAbwYX5m8Wd9sDVC9yav"'
      initial_storage: '(Pair "edsigthTzJ8X7MPmNeEwybRAvdxS1pupqcM5Mk4uCuyZAe7uEk68YpuGDeViW8wSXMrCi5CwoNgqs8V2w8ayB5dMJzrYCHhD8C7" "hello")'
      final_storage: '(Pair "edsigthTzJ8X7MPmNeEwybRAvdxS1pupqcM5Mk4uCuyZAe7uEk68YpuGDeViW8wSXMrCi5CwoNgqs8V2w8ayB5dMJzrYCHhD8C7"        "hello")'
  COMPARE:
    category: arithmetic
    documentation_short: 'Compare two values'
    documentation: |
      Comparison only works on a class of types that we call
      comparable. The ``COMPARE`` instruction is defined in an ad hoc way
      for each comparable type, but the result of ``COMPARE`` is
      always an ``int``, which can in turn be checked in a generic
      manner using the ``EQ``, ``NEQ``, ``LT``, ``GT``, ``LE`` and
      ``GE`` combinators.

      The result of ``COMPARE`` is ``0`` if the top two elements of
      the stack are equal, negative if the first element in the stack
      is less than the second, and positive otherwise.

    examples:
    - name: A variety of comparisons
      description: |
          This contract demonstrate several types of comparisons over different values.

      path: opcodes/compare.tz
      input: 'Unit'
      initial_storage: 'Unit'
      final_storage: 'Unit'
  CONCAT:
    category: data_structure
    documentation_short: Concatenate a string, byte sequence, string list or byte sequence list
    documentation: |
      The ``CONCAT`` operator is overloaded four times:

       - The first version takes two string operands and pushes their concatenation, as a string.
       - The second takes a list of strings and pushes the concatenation of all strings in the list, as a string.
       - The third version takes two byte sequences and pushes their concatenation, as a byte sequence.
       - The fourth version takes a list of byte sequences and pushes the concatenation of all byte sequences in the list, as a byte sequence.

    examples:
      - name: Concatenation of two strings
        description: This example takes a list of strings as parameter. It prepends ``"Hello "`` to each of them and stores the result.
        path: opcodes/concat_hello.tz
        input: '{ "John" ; "Jane" }'
        initial_storage: "{}"
        final_storage: '{ "Hello John" ; "Hello Jane" }'
      - name: Concatenation of list of strings
        description: This example takes a list of strings as parameter and concatenates them, and prepends value in storage and stores the resulting string.
        path: opcodes/list_concat.tz
        input: '{ " " ; "World" ; "!" }'
        initial_storage: '"Hello"'
        final_storage: '"Hello World!"'
      - name: Concatenation of two byte sequences
        description: This example takes a list of byte sequences as parameter. It prepends ``0xff`` to each of them and stores the result.
        path: opcodes/concat_hello_bytes.tz
        input: '{ 0xab ; 0xcd }'
        initial_storage: "{}"
        final_storage: '{ 0xffab ; 0xffcd }'
      - name: Concatenation of list of byte sequences
        description: This example takes a list of byte sequences as parameter and concatenates them, and prepends the value in storage and stores the resulting byte sequence.
        path: opcodes/list_concat_bytes.tz
        input: '{ 0xbe ; 0xef }'
        initial_storage: '0xdead'
        final_storage: '0xdeadbeef'

  CONTRACT:
    category: blockchain
    documentation_short: 'Cast an address to a typed contract'
    documentation: |
      Casts from an ``address`` to a typed ``contract ty``.
      If and only if the address is a valid Tezos contract address with the type ``ty``,
      then the result is ``Some contract`` is pushed.
      If the address belongs to an implicit contract, then the type parameter ``ty`` must be ``unit``.
      If any of these conditions are not fulfilled, ``None`` is pushed.

    examples:
    - name: A variety of comparisons
      description: |
          This contract receives an ``address`` by parameter, and converts it to a ``contract unit``.

      path: opcodes/contract.tz
      input: '"tz1b7tUupMgCNw2cCLpKTkSD1NZzB5TkP2sv"'
      initial_storage: 'Unit'
      final_storage: 'Unit'

  CONS:
    category: data_structure
    documentation_short: Prepend an element to a list
    documentation: |
      Prepends the element at the top of the stack to the list that is
      the second element of the stack.

    examples:
    - name: Prepend to storage.
      description: This contracts keeps a list of integers in storage and takes an integer as parameter. It prepends the parameter to the stored list.
      path: opcodes/cons.tz
      input: '5'
      initial_storage: "{ 99 }"
      final_storage: "{ 5 ; 99 }"

  CREATE_CONTRACT:
    category: blockchain
    documentation_short: Push a contract creation operation
    documentation: |
      Push a contract creation operation (an origination) based on a
      literal. The operands are the optional delegate, the initial
      amount taken from the currently executed contract, and the
      initial storage of the originated contract.  The contract is
      returned as a first class value (to be dropped, passed as
      parameter or stored), along with its address.

      The ``CONTRACT 'p`` instruction applied to this resulting
      address will fail until the contract is actually originated,
      that is, after contract execution. It follows that a contract
      cannot return a list of operations that creates a contract, and
      then calls the same contract.

  CREATE_ACCOUNT:
    category: deprecated
    documentation_short: Push an account creation operation
    documentation: |
      Takes as operands the manager, optional delegate, the delegatable flag
      and finally the initial amount taken from the currently executed
      contract. This instruction originates a contract with two entrypoints;
      ``%default`` of type ``unit`` that does nothing and ``%do`` of type
      ``lambda unit (list operation)`` that executes and returns the
      parameter if the sender is the contract's manager.


  EDIV:
    category: arithmetic
    documentation_short: Euclidean division
    documentation: |
      Consumes two numbers ``x`` and ``y`` (of either ``int`` or
      ``nat``). It returns ``None`` if ``y`` is zero, otherwise, it returns ``Some (Pair
      q r)``, where
      ``q = x / y`` and ``r = x mod y``, such that ``q * y + r = x``, and ``0 ≤ r < y``.
      That is, the quotient ``q`` is rounded down to the nearest integer and not rounded towards 0.

      ========    ======  ====================
       ``x``       ``y``   Results
      ========    ======  ====================
       ``13``     ``3``   ``Some (Pair 4 1)``
       ``-13``    ``3``   ``Some (Pair -5 2)``
       ``13``     ``-3``  ``Some (Pair -4 1)``
       ``-13``    ``-3``  ``Some (Pair 5 2)``
       ``13``     ``0``   ``None``
      ========    ======  ====================

  EMPTY_MAP:
    category: data_structure
    documentation_short: Build a new, empty ``map`` from ``kty`` to ``vty``
    documentation: |
      Build a new, empty map from keys of a given type ``kty`` to values of
      the other given type ``vty``.

      The ``cty`` type must be comparable.

  EMPTY_BIG_MAP:
    category: data_structure
    documentation_short: Build a new, empty ``big_map`` from ``kty`` to ``vty``
    documentation: |
      Build a new, empty map from keys of a given type ``kty`` to values of
      the other given type ``vty``.

      The ``cty`` type must be comparable. The ``vty`` type cannot be
      a ``operation`` or ``big_map``.

  EMPTY_SET:
    category: data_structure
    documentation_short: Build a new, empty set for elements of type ``cty``
    documentation: |
      Build a new, empty set for elements of a given
      type ``cty``.

      The ``cty`` type must be comparable.

  EQ:
    category: arithmetic
    documentation_short: Check that the top of the stack EQuals zero
    documentation: |
      The ``EQ`` instruction consumes an integer and leaves ``True``
      on the stack if it is ``0`` and ``False`` otherwise.

      It is typically composed with ``COMPARE``: the instruction sequence
      ``COMPARE; EQ`` leaves ``True`` on the stack if the two top
      stack elements are equal, and ``False`` otherwise.

  NEQ:
    category: arithmetic
    documentation_short: Check that the top of the stack does Not EQual zero
    documentation: |
      The ``NEQ`` instruction consumes an integer and leaves ``True``
      on the stack if it is not ``0`` and ``False`` otherwise.

      It is typically composed with ``COMPARE``: the instruction sequence
      ``COMPARE; NEQ`` leaves ``True`` on the stack if the two top
      stack elements are not equal, and ``False`` otherwise.

  LT:
    category: arithmetic
    documentation_short: Check that the top of the stack is Less Than zero
    documentation: |
      The ``LT`` instruction consumes an integer and leaves ``True``
      on the stack if it is less than ``0`` and ``False`` otherwise.

      It is typically composed with ``COMPARE``: the instruction sequence
      ``COMPARE; LT`` leaves ``True`` on the stack if the first stack
      element is less than the second, and ``False`` otherwise.

  GT:
    category: arithmetic
    documentation_short: Check that the top of the stack is Greater Than zero
    documentation: |
      The ``GT`` instruction consumes an integer and leaves ``True``
      on the stack if it is greater than ``0`` and ``False`` otherwise.

      It is typically composed with ``COMPARE``: the instruction sequence
      ``COMPARE; GT`` leaves ``True`` on the stack if the first stack
      element is greater than the second, and ``False`` otherwise.

  LE:
    category: arithmetic
    documentation_short: Check that the top of the stack is Less Than or Equal to zero
    documentation: |
      The ``LE`` instruction consumes an integer and leaves ``True``
      on the stack if it is less than or equal to ``0`` or ``False`` otherwise.

      It typically follows a ``COMPARE`` instruction. The sequence of instructions
      ``COMPARE; LE`` leaves ``True`` on the stack if the first stack
      element is less than or equal to the second, and ``False`` otherwise.

  GE:
    category: arithmetic
    documentation_short: Check that the top of the stack is Greater Than or Equal to zero
    documentation: |
      The ``GE`` instruction consumes an integer and leaves ``True``
      on the stack if it is greater than or equal to ``0`` and ``False`` otherwise.

      It is typically composed with ``COMPARE``: the instruction sequence
      ``COMPARE; GE`` leaves ``True`` on the stack if the first stack
      element is greater than or equal to the second, and ``False``
      otherwise.

  EXEC:
    category: control_structure
    documentation_short: Execute a function from the stack
    documentation: |
      The ``EXEC`` instruction consumes a value ``x`` of type ``a``
      and a value ``f`` of type ``lambda a b``, applies the lambda to
      ``x`` and leaves the results, of type ``b``,  on the stack.


  APPLY:
    category: control_structure
    documentation_short: Partially apply a tuplified function from the stack
    documentation: |
      Partially apply a tuplified function from the stack. That is,
      the ``APPLY`` instruction consumes a value ``d`` of type ``ty1``
      and a value ``i`` of type ``lambda (Pair ty1 ty2) ty3``.
      It `partially <https://en.wikipedia.org/wiki/Partial_application>`_ applies the lambda to ``d``, hence producing a
      new lambda of type ``lambda ty2 ty3`` on the stack.
      Intuitively, this amounts to creating a new function that acts
      like ``i`` but with the first parameter fixed to ``d``.

      The new lambda is storable, and thus values that cannot be
      stored (values of type ``operation``, ``contract _`` and ``big
      map _ _``) cannot be captured by ``APPLY`` (cannot appear in
      ``ty1``).

  GET:
    category: data_structure
    documentation_short: Access an element in a ``map`` or ``big_map``
    documentation: |
      The instruction ``GET`` consumes a key and a ``map`` or ``big_map`` and returns an
      optional value: ``None`` if the key is not present in the data structure,
      and ``Some v`` if it is present and mapped to ``v``.

  MEM:
    category: data_structure
    documentation_short: Check for the presence of a binding for a key in a ``map``, ``set`` or ``big_map``
    documentation: |
      The instruction ``MEM`` consumes a value and a data structure of
      type ``map``, ``set`` or ``big_map``.

      For ``map`` and ``big_map``, ``MEM`` returns ``True`` if the
      value is a bound key in the data structure, and ``False``
      otherwise.

      For ``set``, ``True`` is returned if the value is a member of
      the ``set``, and ``False`` otherwise.


  UPDATE:
    category: data_structure
    documentation_short: Add or remove an element in a ``map``, ``big_map`` or ``set``
    documentation: |
      For values of type ``map`` and ``big_map``, the instruction ``UPDATE`` consumes
      a key, an optional value and a value of type ``map`` or ``big_map``.
      It returns the same map, but updated in the following way:

        - If the value is ``Some x`` then key is assigned to ``x`` in
          the resulting map.
        - If the value is ``None`` and the key is present in the map,
          then it is removed in the resulting map. If the key is not
          present, an unmodified map is returned.

      For values of type ``set``, the instruction ``UPDATE`` consumes
      a value ``v``, a boolean flag ``b`` and a set ``s``.  It returns the same set,
      but updated in the following way:

        - If ``b`` is ``True`` then the value ``v`` is added to the set ``s``.
          If ``v`` was already present in ``s``, then the original set is returned.
        - If ``b`` is ``False`` then the value ``v`` is removed from ``s``.
          If ``v`` is not present in ``s``, then the original set is returned.

  MAP:
    category: data_structure
    documentation_short: Apply the body expression to each element of a ``list`` or ``map``.
    documentation: |

      Map over a ``list`` or ``map``.

      Update a structure by applying the body expression to each
      of its elements:

        - In the case of a ``list`` of elements of type ``ty1``, the body is applied to each
          element, and must thus have the type ``ty1 : A => A``.
        - In the case of a ``map`` of keys of type ``ty1`` and values of type ``ty2``, the body is
          applied to each binding ``key`` to value ``val`` in the form of a pair ``Pair key
          val``. Thus, the body must have the type ``Pair ty1 ty2 : A => A``.

      In each case, the body has access to and can modify the
      underlying stack.

  TRANSFER_TOKENS:
    category: blockchain
    documentation_short: Push a transaction operation
    documentation: |
      The ``TRANSFER_TOKENS`` instruction consumes a value ``v`` of type ``ty1``,
      an amount ``a`` in ``mutez`` and a contract ``c`` of type ``contract ty1``. It returns
      a transfer operation that will send ``a`` mutez to the
      specified contract ``c`` with the parameter ``v``.

      Consequently, the parameter value must be consistent with the
      parameter type of the contract. In the case the contract is an
      implicit account, then the parameter must be of type ``unit``.

  HASH_KEY:
    category: crypto
    documentation_short: Compute the Base58Check of a public key
    documentation: |
      The ``HASH_KEY`` instruction computes the
      `Base58Check <https://en.bitcoin.it/wiki/Base58Check>`_ of a public
      key.


  IMPLICIT_ACCOUNT:
    category: blockchain
    documentation_short: Create an implicit account
    documentation: |
      Return a default contract (an implicit account) with the given
      public/private key pair. Any funds deposited in this contract
      can immediately be spent by the holder of the private key. This
      contract cannot execute Michelson code and will always exist on
      the blockchain.

  ITER:
    category: control_structure
    documentation_short: Iterate over a ``set``, ``list`` or ``map``
    documentation: |

      Iterate on a ``set``, ``list`` or ``map``.

      Consume a structure by applying the body expression to each of its
      elements:

        - In the case of a ``list`` or ``set`` of elements of type ``ty1``, the body is applied to each
          element, and must thus have the type ``ty1 : A => A``.
        - In the case of a ``map`` of keys of type ``ty1`` and values of type ``ty2``, the body is
          applied to each binding ``key`` to value ``val`` in the form of a pair ``Pair key
          val``. Thus, the body must have the type ``Pair ty1 ty2 : A => A``.

      In each case, the body has access to and can modify the underlying stack.

  LAMBDA:
    category: control_structure
    documentation_short: Push a lambda onto the stack
    documentation: |
      Push a lambda with parameter type ``ty1``, return type ``ty2`` and body ``code``
      onto the stack.

  LOOP:
    category: control_structure
    documentation_short: A generic loop
    documentation: |

      The instruction ``LOOP`` consumes a stack ``b : S`` of type
      ``bool : A``, i.e. where ``b`` is boolean and the rest of the
      stack is of any type ``A``. The body of the loop, ``code``, is
      executed as long as ``b`` is ``True``. The body has access to the stack ``S``
      but must produce a stack of type ``bool : A``. If ``b`` is
      ``False``, then the loop is terminated with the resulting stack ``S``.

  LSL:
    category: arithmetic
    documentation_short: Logically left shift a natural number
    documentation: |

      The ``LSL`` instruction consumes two natural numbers and produces
      the first number logically left-shifted by second number.

      This instruction is only defined if the second number is less
      than or equal to 256.

  LSR:
    category: arithmetic
    documentation_short: Logically right shift a natural number
    documentation: |
      The ``LSR`` instruction consumes two natural numbers and produces
      the first number logically right-shifted by second number.

      This instruction is only defined if the second number is less than or equal to 256.

  MUL:
    category: arithmetic
    documentation_short: Multiply two numerical values
    documentation: |
      The ``MUL`` instruction consumes two natural numbers (int or
      nat) and produces their product. ``MUL`` can also be used to
      multiply a ``mutez`` with a natural number.

  NOT:
    category: logic
    documentation_short: Boolean negation and bitwise complement
    documentation: |
      The ``NOT`` instruction is defined for ``bool``,
      ``nat`` and ``int``.

      For ``bool``, it returns the logical negation of its operand.

      For numerical values, it returns the `two's
      complement <https://en.wikipedia.org/wiki/Two%27s_complement>`_ as
      an ``int``. The return type is ``int`` and not ``nat`` because the sign is
      also negated. For instance, the boolean negation of 0 is -1. To
      get a natural back, a possibility is to use AND with an unsigned
      mask afterwards.

  NEG:
    category: arithmetic
    documentation_short: Negate a numerical value
    documentation: |

      The ``NEG`` instruction consumes a natural number (``int`` or
      ``nat``) and produces their negation, in the form of an
      ``int``.

  NIL:
    category: data_structure
    documentation_short: Push an empty list
    documentation: |

      The ``NIL ty1`` instruction produces the empty list of type ``list ty1``.
      It is functionally equivalent to ``PUSH (list ty1) {}``.

  NONE:
    category: data_structure
    documentation_short: Push the absent optional value
    documentation: |

      The ``NONE ty1`` instruction produces the
      absent optional value ``None`` of type ``option ty1``.

      It is functionally equivalent to ``PUSH (option ty1) None``.

  SOME:
    category: data_structure
    documentation_short: Wrap an existing optional value
    documentation: |

      The ``SOME`` instruction wraps the top element ``x`` of the
      stack, of type ``ty1`` into the existing optional value ``Some
      x`` of type ``option ty1``.

  SENDER:
    category: blockchain
    documentation_short: Push the contract that initiated the current internal transaction
    documentation: |

      Push the contract that initiated the current
      internal transaction. It may be the ``SOURCE``, but may
      also not if the source sent an order to an intermediate
      smart contract, which then called the current contract.

      Consider a scenario involving two contracts, ``receiver`` and
      ``proxy``.  The contract ``proxy``, transfers any amount
      received in a call to ``receiver``.  Assume a third
      contract ``bootstrap2`` creates a transaction to the ``proxy``
      contract sending 99 ꜩ . Then ``proxy`` creates an internal
      transaction that calls ``receiver``:

      .. image:: static/proxy-receiver.svg
        :alt: Distinction between ``SOURCE`` and ``SENDER``.

      In this scenario, the source of the internal transaction (from
      ``proxy`` to ``receiver``) is ``bootstrap2``, whereas the sender
      of that transaction is the ``proxy``. That is, if ``SOURCE`` is
      called in ``receiver``, then address of ``bootstrap2`` is
      returned. If ``SENDER`` is called in ``receiver``, then address
      of ``proxy`` is returned.

      If instead, ``bootstrap2`` calls ``receiver`` directly, then
      ``bootstrap2`` would be both source and sender.

  SOURCE:
    category: blockchain
    documentation_short: Push the contract that initiated the current transaction
    documentation: |
      Push the contract that initiated the current
      transaction, i.e. the contract that paid the fees and
      storage cost, and whose manager signed the operation
      that was sent on the blockchain.

      Note that since ``TRANSFER_TOKENS`` instructions can be chained,
      ``SOURCE`` and ``SENDER`` are not necessarily the same.  See
      ``SENDER`` for a more detailed discussion of this distinction.

  SELF:
    category: blockchain
    documentation_short: Push the current contract
    documentation: |
      The ``SELF`` contract pushes the current contract, of type
      ``contract ty1`` where ``ty1`` is the type of the current
      contract.

  NOW:
    category: blockchain
    documentation_short: Push block timestamp
    documentation: |
      Push the timestamp of the block whose validation triggered this
      execution. This timestamp does not change during the execution of
      the contract.

  OR:
    category: logic
    documentation_short: Boolean and bitwise OR
    documentation: |
      The instruction ``OR`` is defined on boolean and natural number operands.
      In the former case, the result is the logical OR of the operands.
      In the latter case, the result is the bitwise OR of the operands.

  SET_DELEGATE:
    category: blockchain
    documentation_short: Push a delegation operation
    documentation: |
      The ``SET_DELEGATE`` is used to add, update or remove a
      delegation.  It consumes an operand of type ``option
      key_hash``.

      If the operand is ``None``, then the produced operation will
      remove the executing contracts current delegation, if any. If
      the operand is ``Some kh``, then the produced operation will
      update or add a delegation, from the executing contract to the
      implicit account specified by ``kh``.

  SIZE:
    category: data_structure
    documentation_short: Obtain size of a ``string``, ``list``, ``set``, ``map`` or byte sequence

    documentation: |
      The ``SIZE`` instruction consumes the
      top element of the stack and returns its "size" (see below) as a ``nat``. It is defined for values of type  ``string``, ``list``, ``set``, ``map`` and byte sequences ``bytes``.

      - For a ``string`` value, it returns the number of characters.
      - For a ``list``, it returns the number of elements.
      - For a ``set``, it returns the number of elements.
      - For a ``map``, it returns the number of key-value pairs.
      - For a byte sequence ``bytes``, it returns the number of bytes in the sequence.


  SLICE:
    category: data_structure
    documentation_short: Obtain a substring or subsequence of a ``string`` respectively byte sequence ``bytes``

    documentation: |
      The ``SLICE`` instruction consumes two natural numbers ``offset`` and ``length``
      and a character sequence (``string``) or bytes sequence (``bytes``).

      If ``offset`` and ``length`` are in bounds, i.e.
      ``offset + start  < len``, then
      it returns a substring, respectively subsequence, ``Some v`` of
      length ``length`` starting at ``offset`` (where offset 0 denotes
      the first element) of the sequence.

      If ``offset`` and ``length`` is out of bounds, i.e.
      ``offset + length >= len`` (where ``len`` is the length
      of the sequence), then ``None`` is returned.

  STEPS_TO_QUOTA:
    category: deprecated
    documentation_short: Push the remaining steps before the contract execution must terminate

    documentation: |
      *Deprecated*. The ``STEPS_TO_QUOTA`` instruction pushes the
      number of steps remaining before contract execution is aborted
      due to gas exhaustion.

  SUB:
    category: arithmetic
    documentation_short: Subtract two numerical values
    documentation: |

      Consumes two numerical values and returns their difference. The
      return type depends on the operand type:

        - Integers can be subtracted from natural numbers and
          vice versa, in which case the result type is always an
          integer.
        - Integers can be subtracted from timestamps, in which case the
          result is the timestamp offset by the integer.
        - Timestamps can also be subtracted from timestamps, in which
          case the result is a integer denoting their difference
          in seconds.

  UNIT:
    category: data_structure
    documentation_short: Push the unit value onto the stack

  XOR:
    category: logic
    documentation_short: Boolean and bitwise eXclusive OR
    documentation: |
      The instruction ``XOR`` is defined on boolean and natural number operands.
      In the former case, the result is the logical XOR of the operands.
      In the latter case, the result is the bitwise XOR of the operands.

  DIG:
    category: stack
    documentation_short: Retrieve the ``n``\ th element of the stack
    documentation: |
      ``DIG n`` consumes a stack that contains at least ``n``
      elements.  It removes the ``n``\ th element of the stack, and
      puts it on the top of the stack. The element on top of the stack
      is the 0th element, so that ``DIG 0`` is a no-op.
      In other words, ``DIG`` transforms a stack on the form ``x0 : x1 :
      ... : xn : ...`` into the stack ``xn : x0 : x1 : ...``.

      The inverse of ``DIG`` is ``DUG``.

  DUG:
    category: stack
    documentation_short: Insert the top element at depth ``n``
    documentation: |
      ``DUG n`` consumes a stack that contains at least ``n``
      elements.  It removes the top element of the stack, and inserts
      it at the ``n``\ th level in the stack.  The element on top of
      the stack is at depth ``0`` so that ``DUG 0`` is a no-op.  In
      other words, ``DUG`` transforms a stack on the form ``x0 : x1 :
      ... : xn : ...`` into the stack ``x0 : x1 : ... : x0 : xn :
      ...``.

      The inverse of ``DUG`` is ``DIG``.

  INT:
    category: arithmetic
    documentation_short: Convert a natural number to an integer

  ISNAT:
    category: arithmetic
    documentation_short: Convert a non-negative integer to a natural number
    documentation: |
      The ``ISNAT`` instruction consumes an integer ``i`` and returns
      a value of type ``option nat``.  If the integer is non-negative,
      ``Some n`` is returned, where ``n`` is equal to ``i`` but
      represented as a natural number. Otherwise, ``None`` is
      returned.

types:
  string:
    documentation_short: "A string of characters"
    comparable: true
    pushable: true
    packable: true
    passable: true
    storable: true
    big_map_value: true
    documentation: |
      The current version of Michelson restricts strings to be the printable
      subset of 7-bit ASCII, namely characters with codes from within
      `[32, 126]` range, plus the following escape characters ``\n``,
      ``\\``, ``\"``. Unescaped line breaks (both ``\n`` and ``\r``)
      cannot appear in a string.
    examples:
      - "\"foo\""
      - "\"ABC\\n123\""
  nat:
    documentation_short: "An arbitrary-precision natural number"
    comparable: true
    pushable: true
    packable: true
    passable: true
    storable: true
    big_map_value: true
    examples:
      - 0
      - 1
      - 99999
  int:
    documentation_short: "An arbitrary-precision integer"
    comparable: true
    pushable: true
    packable: true
    passable: true
    storable: true
    big_map_value: true
    examples:
      - -99999
      - -1
      - 0
      - 1
      - 99999
  bytes:
    documentation_short: "A sequence of bytes"
    comparable: true
    pushable: true
    packable: true
    passable: true
    storable: true
    big_map_value: true
    examples:
      - "0x"
      - "0xABCDEF42"
  bool:
    documentation_short: "A boolean"
    comparable: true
    pushable: true
    packable: true
    passable: true
    storable: true
    big_map_value: true
    documentation: |
      The type for booleans whose values are ``True`` and ``False``.

    examples:
      - "True"
      - "False"
  mutez:
    documentation_short: "A specific type for manipulating tokens"
    comparable: true
    pushable: true
    packable: true
    passable: true
    storable: true
    big_map_value: true
    examples:
      - 0
      - 1
      - 99999
  key_hash:
    documentation_short: "A hash of a public cryptography key"
    comparable: true
    pushable: true
    packable: true
    passable: true
    storable: true
    big_map_value: true
    examples:
      - '"tz1KqTpEZ7Yob7QbPE4Hy4Wo8fHG8LhKxZSx"'
      - '"tz1XPTDmvT3vVE5Uunngmixm7gj7zmdbPq6k"'

  timestamp:
    documentation_short: "A real-world date"
    comparable: true
    pushable: true
    packable: true
    passable: true
    storable: true
    big_map_value: true
    examples:
      - '"2019-09-26T10:59:51Z"'
      - '1571659294'
    documentation: |
      Literal ``timestamp``\ s are written either using ``RFC3339`` notation
      in a string (readable), or as the number of seconds since Epoch in
      a natural (optimized).


  key:
    documentation_short: "A public cryptography key"
    comparable: false
    pushable: true
    packable: true
    passable: true
    storable: true
    big_map_value: true
    examples:
      - '"edpkuBknW28nW72KG6RoHtYW7p12T6GKc7nAbwYX5m8Wd9sDVC9yav"'
      - '"edpkuJqtDcA2m2muMxViSM47MPsGQzmyjnNTawUPqR8vZTAMcx61ES"'

  unit:
    documentation_short: The type whose only value is ``Unit``
    comparable: false
    passable: true
    storable: true
    big_map_value: true
    pushable: true
    packable: true
    documentation: |
      The type whose only value is ``Unit``, to use as a placeholder
      when some result or parameter is non-necessary. For instance,
      when the only goal of a contract is to update its storage.
    examples:
      - Unit

  signature:
    documentation_short: "A cryptographic signature"
    comparable: false
    passable: true
    storable: true
    big_map_value: true
    pushable: true
    packable: true
    examples:
      - '"edsigthTzJ8X7MPmNeEwybRAvdxS1pupqcM5Mk4uCuyZAe7uEk68YpuGDeViW8wSXMrCi5CwoNgqs8V2w8ayB5dMJzrYCHhD8C7"'
      - '"spsig1PPUFZucuAQybs5wsqsNQ68QNgFaBnVKMFaoZZfi1BtNnuCAWnmL9wVy5HfHkR6AeodjVGxpBVVSYcJKyMURn6K1yknYLm"'
  option:
    documentation_short: An optional value
    comparable: false
    passable: true
    storable: true
    big_map_value: true
    pushable: true
    packable: true
    documentation: |
      Optional value of type ``vty`` that we note ``None`` or ``(Some v)``.
    examples:
      - ['None', 'option unit']
      - ['Some "foo"', 'option string']

  list:
    documentation_short: "A single, immutable, homogeneous linked list"
    comparable: false
    pushable: true
    packable: true
    passable: true
    storable: true
    big_map_value: true
    documentation: |
      A single, immutable, homogeneous linked list, whose elements are
      of type ``type``, and that we note ``{}`` for the empty list or
      ``{ first ; ... }``. In the semantics, we use the less-than and
      greater-than sign (< and >) to denote a subsequence of
      elements. For instance ``{ head ; <tail> }``.
    examples:
      - ["{}", 'list unit']
      - ["{ 0 ; 10 }", 'list nat']
      - ["{ Some 10 ; None }", 'list (option int)']
  set:
    documentation_short: "An immutable set of comparable values of type ``cty``"
    comparable: false
    passable: true
    storable: true
    big_map_value: true
    pushable: true
    packable: true
    documentation: |
      Immutable sets of comparable values of type ``cty`` that we note
      as lists ``{ item ; ... }``, of course with their elements
      unique, and sorted.
    examples:
      - ["{}", 'set bool']
      - ["{ 0 ; 3 ; 4 }", 'set nat']

  contract:
    documentation_short: "Address of a contract, where `type` is the contract's parameter type"
    insertions: [ 'contract nat' ]
    comparable: false
    literal: false
    passable: true
    big_map_value: true
    pushable: false
    packable: true
    storable: false
    documentation:
      A value of type ``contract t`` is guaranteed to be a valid,
      existing account whose parameter type is ``t``.  This can be
      opposed to the ``address`` type, that merely gives the guarantee
      that the value has the form of a Tezos address.

      Values of the ``contract`` type cannot be serialized using
      ``PACK``, nor can they be taken as a parameter or be
      stored. There are not literal values of type contract.
      Instead, such values are created using instructions such as
      ``CONTRACT`` or ``IMPLICIT_ACCOUNT``.

  address:
    documentation_short: "Address of an untyped contract"
    passable: true
    storable: true
    big_map_value: true
    comparable: true
    pushable: true
    packable: true
    documentation: |
      The ``address`` type merely gives the guarantee that the value
      has the form of a Tezos address, as opposed to ``contract``
      that guarantees that the value is indeed a valid, existing
      account.

      A valid Tezos address is a string prefixed by either ``tz1``,
      ``tz2``, ``tz3`` or ``KT1`` and followed by a Base58 encoded
      hash and terminated by a 4-byte checksum.

      The prefix designates the type of address:

      - ``tz1`` addresses are followed by a ed25519 public key hash
      - ``tz2`` addresses are followed by a Secp256k1 public key hash
      - ``tz3`` addresses are followed by a NIST p256r1 public key hash
      - ``KT1`` addresses are followed by a contract hash

      Addresses prefixed by ``tz1``, ``tz2`` and ``tz3`` designate
      implicit accounts, whereas those prefixed ``KT1`` designate
      originated accounts.

    examples:
      - '"KT1ThEdxfUcWUwqsdergy3QnbCWGHSUHeHJq"'
      - '"tz1KqTpEZ7Yob7QbPE4Hy4Wo8fHG8LhKxZSx"'
      - '"tz2VGBaXuS6rnaa5hpC92qkgadRJKdEbeGwc"'
      - '"tz3WEJYwJ6pPwVbSL8FrSoAXRmFHHZTuEnMA"'

  operation:
    documentation_short: "An internal operation emitted by a contract"
    passable: false
    pushable: false
    storable: false
    big_map_value: false
    packable: false
    documentation:
      There are not literal values of type ``operation``.
      Instead, such values are created using the primitive such as
      ``TRANSFER_TOKEN`` and ``CREATE_ACCOUNT``.

    comparable: false
  pair:
    documentation_short: A pair of values
    passable: true
    storable: true
    big_map_value: true
    comparable: true
    pushable: true
    packable: true
    documentation: |
      A pair of values ``a`` and
      ``b`` of types ``ty1`` and ``ty2``, that we write ``(Pair a
      b)``.

      Pairs are comparable under the restriction that the left component does not itself contain a pair. For example the following values are comparable:
        - ``Pair 10 "foo"``
        - ``Pair "foo" (Pair "bar" "baz")``
        - ``Pair True (Pair "bar" (Pair 10 -5))``

      On the other hand, these values are not comparable:
        - ``Pair (Pair "bar" "baz") "foo"``
        - ``Pair "foo" (Pair (Pair "bar" "baz") "baz")``

    examples:
      - ["(Pair 0 True)", 'pair int bool']

  or:
    documentation_short: A union of two types
    passable: true
    storable: true
    big_map_value: true
    pushable: true
    packable: true
    comparable: false
    documentation: |
      A union of two types: a value holding either a value ``a`` of
      type ``ty1`` or a value ``b`` of type ``ty2``, that we write
      ``(Left a)`` or ``(Right b)``.
    examples:
      - ['(Left True)', 'or bool string']
      - ['(Right "foo")', 'or bool string']

  lambda:
    documentation_short: A lambda with given parameter and return types
    passable: true
    storable: true
    big_map_value: true
    pushable: true
    packable: true
    comparable: false
    examples:
      - ['{ }', 'lambda unit unit']
      - ['{ PUSH nat 1; ADD }', 'lambda nat nat']

  map:
    documentation_short: An immutable map from ``kty`` to ``vty``
    passable: true
    storable: true
    big_map_value: true
    pushable: true
    packable: true
    comparable: false
    documentation: |
      Immutable maps from keys of type ``kty`` and values of type
      ``vty`` that we note ``{ Elt key value ; ... }``, with keys
      sorted.
    examples:
      - ['{}', 'map nat unit']
      - ['{ Elt 0 0xCB ; Elt 1 0xAB }', 'map nat bytes']

  big_map:
    documentation_short: A lazily deserialized map from ``kty`` to ``vty``
    comparable: false
    packable: false
    passable: true
    pushable: false
    storable: true
    big_map_value: false
    documentation: |
      Lazily deserialized maps from keys of type ``kty`` of values of
      type ``vty`` that we note ``{ Elt key value ; ... }``, with keys
      sorted.  These maps should be used if you intend to store large
      amounts of data in a map. Operations on ``big_map``\ s have
      higher gas costs than those over standard maps, as data is
      lazily deserialized. However, a ``big_map`` has a lower
      storage cost than a standard map of the same size.

      The behavior of ``GET``, ``UPDATE`` and ``MEM`` is the same on
      ``big_map``\ s as on standard maps, except that under
      the hood, elements are loaded and deserialized on demand.

      Literal ``big_map``\ s cannot be pushed directly in contract
      code. Instead, they must be created using ``EMPTY_BIG_MAP`` and
      manipulated using ``GET``, ``UPDATE`` and ``MEM``. However,
      literal ``big_map``\ s are used when originating and calling
      contracts using ``tezos-client``.

      Values of the ``big_map`` type cannot be serialized using ``PACK``.
    examples:
      - ['{}', 'big_map nat bytes']
      - ['{ Elt 0 0xCB ; Elt 1 0xAB }', 'big_map nat bytes']

  chain_id:
    documentation_short: A chain identifier
    passable: true
    storable: true
    big_map_value: true
    pushable: true
    packable: true
    comparable: false
    documentation: |
      An identifier for a chain, used to distinguish the test and the main chains.
    examples:
      - '0x7a06a770'